---
import Section from '../ui/Section.astro';
import Card from '../ui/Card.astro';
import Icon from '../ui/Icon.astro';
import FadeIn from '../animations/FadeIn.astro';

interface Metric {
  icon: string;
  value: string;
  label: string;
  description?: string;
  trend?: 'up' | 'down';
  trendValue?: string;
}

interface Props {
  metrics: Metric[];
  title?: string;
  description?: string;
  highlights?: string[];
}

const {
  metrics,
  title = "Projektresultater",
  description = "MÃ¥lbare resultater og indvirkning fra projektet",
  highlights
} = Astro.props;
---

<Section>
  <FadeIn>
    <div class="text-center mb-12">
      <h2 class="text-4xl md:text-5xl font-bold mb-4">
        {title}
      </h2>
      <p class="text-xl text-gray-300 max-w-2xl mx-auto">
        {description}
      </p>
    </div>
  </FadeIn>

  <!-- Metrics Grid -->
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-12">
    {metrics.map((metric, index) => (
      <FadeIn delay={index * 0.1}>
        <Card class="text-center group">
          <div class="p-6">
            <div class="w-16 h-16 bg-gradient-to-br from-primary-500 to-primary-600 rounded-2xl flex items-center justify-center mx-auto mb-4 group-hover:scale-110 transition-transform duration-300">
              <Icon name={metric.icon} class="w-8 h-8 text-white" />
            </div>

            <div class="text-4xl md:text-5xl font-bold mb-2 bg-gradient-to-r from-primary-500 to-primary-600 text-transparent bg-clip-text">
              {metric.value}
            </div>

            <div class="text-lg font-semibold mb-2">
              {metric.label}
            </div>

            {metric.description && (
              <p class="text-sm text-gray-400">
                {metric.description}
              </p>
            )}

            {metric.trend && metric.trendValue && (
              <div class={`mt-3 inline-flex items-center gap-1 text-sm font-semibold ${metric.trend === 'up' ? 'text-green-500' : 'text-red-500'}`}>
                <Icon name={metric.trend === 'up' ? 'trending-up' : 'trending-down'} class="w-4 h-4" />
                {metric.trendValue}
              </div>
            )}
          </div>
        </Card>
      </FadeIn>
    ))}
  </div>

  <!-- Highlights -->
  {highlights && highlights.length > 0 && (
    <FadeIn delay={0.3}>
      <Card>
        <div class="p-8">
          <h3 class="text-2xl font-bold mb-6 flex items-center gap-3">
            <Icon name="award" class="w-6 h-6 text-primary-500" />
            Key Highlights
          </h3>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            {highlights.map((highlight) => (
              <div class="flex items-start gap-3">
                <div class="mt-1 flex-shrink-0">
                  <Icon name="check-circle" class="w-5 h-5 text-green-500" />
                </div>
                <p class="text-gray-300">{highlight}</p>
              </div>
            ))}
          </div>
        </div>
      </Card>
    </FadeIn>
  )}
</Section>

<script>
  // Animate metrics when they come into view
  function animateValue(element: HTMLElement, start: number, end: number, duration: number, suffix: string = '') {
    const range = end - start;
    const increment = range / (duration / 16);
    let current = start;

    const timer = setInterval(() => {
      current += increment;
      if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
        element.textContent = end.toString() + suffix;
        clearInterval(timer);
      } else {
        element.textContent = Math.round(current).toString() + suffix;
      }
    }, 16);
  }

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && entry.target instanceof HTMLElement) {
        const text = entry.target.textContent || '';
        const numMatch = text.match(/[\d.]+/);
        const suffix = text.replace(/[\d.\s]/g, '');

        if (numMatch && !entry.target.dataset.animated) {
          entry.target.dataset.animated = 'true';
          const targetValue = parseFloat(numMatch[0]);
          animateValue(entry.target, 0, targetValue, 2000, suffix);
        }
      }
    });
  }, { threshold: 0.5 });

  document.querySelectorAll('.text-4xl').forEach(el => {
    if (el instanceof HTMLElement) {
      observer.observe(el);
    }
  });
</script>
